<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anim3 Chip</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            background: transparent;
        }

        body {
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        :root {
            --base: #111;
            --text: #fff;
            --accent: #D05030;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="anim"></canvas>

    <script>
    let grid, nextGrid;
    let cols, rows;
    let cellSize = 6;
    let isHovered = false;
    let mouseX = -1, mouseY = -1;
    let canvasW, canvasH;

    let kernel = [];
    let kernelRadius = 8;
    let kernelSum = 0;

    window.addEventListener('load', () => {
        let anim = document.getElementById('anim');
        if (!anim) return;

        function resize() {
            let rect = document.body.getBoundingClientRect();
            let w = Math.floor(rect.width);
            let h = Math.floor(rect.height);
            anim.width = w;
            anim.height = h;
            canvasW = w;
            canvasH = h;
            
            let newCols = Math.ceil(w / cellSize);
            let newRows = Math.ceil(h / cellSize);
            if (newCols !== cols || newRows !== rows) {
                cols = newCols;
                rows = newRows;
                setup();
            }
        }
        resize();
        window.addEventListener('resize', resize);

        let ctx = anim.getContext('2d');
        buildKernel();
        setup();

        // Listen for messages from parent (tile hover and mouse position)
        window.addEventListener('message', function(e) {
            if (!e.data) return;
            if (e.data.type === 'hover') {
                isHovered = e.data.value;
                if (!e.data.value) {
                    mouseX = -1;
                    mouseY = -1;
                }
            } else if (e.data.type === 'mousemove') {
                mouseX = Math.floor(e.data.x * cols);
                mouseY = Math.floor(e.data.y * rows);
            }
        });

        loop(ctx);
    });

    function buildKernel() {
        kernel = [];
        kernelSum = 0;
        for (let dy = -kernelRadius; dy <= kernelRadius; dy++) {
            for (let dx = -kernelRadius; dx <= kernelRadius; dx++) {
                let dist = Math.sqrt(dx * dx + dy * dy);
                let dist2 = Math.sqrt((dx - 0.5) * (dx - 0.5) + (dy + 1) * (dy + 1));
                if (dist <= kernelRadius && (dx !== 0 || dy !== 0)) {
                    let weight = bell(dist / kernelRadius, 0.5, 0.15);
                    weight -= 3 * bell(dist2 / kernelRadius, -0.2, 0.3);
                    kernel.push({ dx, dy, weight });
                    kernelSum += weight;
                }
            }
        }
    }

    function bell(x, m, s) {
        return Math.exp(-((x - m) * (x - m)) / (2 * s * s));
    }

    function setup() {
        grid = new Float32Array(cols * rows);
        nextGrid = new Float32Array(cols * rows);
        
        let cx = cols / 2;
        let cy = rows / 2;
        let r = Math.min(cols, rows) / 4;
        
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                let dx = x - cx;
                let dy = y - cy;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < r) {
                    grid[y * cols + x] = Math.random() * 0.5 + 0.25;
                }
            }
        }
    }

    function loop(ctx) {
        let lastTime = 0;

        function frame(time) {
            if (isHovered) {
                let dt = Math.min(50, time - lastTime);
                lastTime = time;
                update(dt / 1000);
                draw(ctx);
            } else {
                lastTime = time;
            }
            requestAnimationFrame(frame);
        }

        requestAnimationFrame(frame);
    }

    function update(dt) {
        if (mouseX >= 0 && mouseY >= 0 && mouseX < cols && mouseY < rows) {
            let r = 9;
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    let nx = mouseX + dx;
                    let ny = mouseY + dy;
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < r) {
                            let idx = ny * cols + nx;
                            let ring = bell(dist / r, 0.5, 0.25) * 0.2;
                            grid[idx] = Math.max(grid[idx], ring);
                        }
                    }
                }
            }
        }

        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                let sum = 0;
                for (let k of kernel) {
                    let nx = (x + k.dx + cols) % cols;
                    let ny = (y + k.dy + rows) % rows;
                    sum += grid[ny * cols + nx] * k.weight;
                }
                sum /= kernelSum;
                
                let current = grid[y * cols + x];
                let growth = growthFunc(sum);
                let newVal = current + growth * dt * 8;
                nextGrid[y * cols + x] = Math.max(0, Math.min(1, newVal));
            }
        }

        let temp = grid;
        grid = nextGrid;
        nextGrid = temp;
    }

    function growthFunc(u) {
        let m = 0.05;
        let s = 0.02;
        return 2 * Math.exp(-((u - m) * (u - m)) / (2 * s * s)) - 1;
    }

    function draw(ctx) {
        let accent = getComputedStyle(ctx.canvas).getPropertyValue("--accent").trim();
        let base = getComputedStyle(ctx.canvas).getPropertyValue("--base").trim();
        
        let ar = parseInt(accent.slice(1, 3), 16);
        let ag = parseInt(accent.slice(3, 5), 16);
        let ab = parseInt(accent.slice(5, 7), 16);
        let br = parseInt(base.slice(1, 3), 16);
        let bg = parseInt(base.slice(3, 5), 16);
        let bb = parseInt(base.slice(5, 7), 16);

        let imageData = ctx.getImageData(0, 0, canvasW, canvasH);
        let data = imageData.data;

        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                let val = grid[y * cols + x];
                val = val * val;
                
                let r = lerp(br, ar, val);
                let g = lerp(bg, ag, val);
                let b = lerp(bb, ab, val);

                for (let py = 0; py < cellSize && y * cellSize + py < canvasH; py++) {
                    for (let px = 0; px < cellSize && x * cellSize + px < canvasW; px++) {
                        let idx = ((y * cellSize + py) * canvasW + (x * cellSize + px)) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 255;
                    }
                }
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    function lerp(a, b, t) {
        return a + (b - a) * t;
    }
    </script>
</body>
</html>

