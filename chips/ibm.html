<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Map</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let isHovering = false;
        let time = 4;
        let lastTime = 4;
        let mapData = null;
        let mapWidth = 0;
        let mapHeight = 0;

        const OCEAN_BASE = { r: 18, g: 18, b: 18 };
        const LAND_BASE = { r: 34, g: 34, b: 34 };
        const ACCENT = { r: 208, g: 80, b: 48 }; // #D05030

        const CELL_SIZE = 12;
        const GAP = 2;

        function hash3(x, y, z) {
            let h = x * 374761393 + y * 668265263 + z * 1274126177;
            h = (h ^ (h >> 13)) * 1274126177;
            return (h & 0x7fffffff) / 0x7fffffff;
        }

        function noiseAt(ix, iy, iz) {
            return hash3(ix, iy, iz) * 2 - 1;
        }

        function smoothstep(t) {
            return t * t * (3 - 2 * t);
        }

        function noise3D(x, y, z) {
            const x0 = Math.floor(x);
            const y0 = Math.floor(y);
            const z0 = Math.floor(z);
            
            const fx = smoothstep(x - x0);
            const fy = smoothstep(y - y0);
            const fz = smoothstep(z - z0);
            
            const n000 = noiseAt(x0, y0, z0);
            const n100 = noiseAt(x0 + 1, y0, z0);
            const n010 = noiseAt(x0, y0 + 1, z0);
            const n110 = noiseAt(x0 + 1, y0 + 1, z0);
            const n001 = noiseAt(x0, y0, z0 + 1);
            const n101 = noiseAt(x0 + 1, y0, z0 + 1);
            const n011 = noiseAt(x0, y0 + 1, z0 + 1);
            const n111 = noiseAt(x0 + 1, y0 + 1, z0 + 1);
            
            const nx00 = n000 + fx * (n100 - n000);
            const nx10 = n010 + fx * (n110 - n010);
            const nx01 = n001 + fx * (n101 - n001);
            const nx11 = n011 + fx * (n111 - n011);
            
            const nxy0 = nx00 + fy * (nx10 - nx00);
            const nxy1 = nx01 + fy * (nx11 - nx01);
            
            return nxy0 + fz * (nxy1 - nxy0);
        }

        function fractalNoise(x, y, t, octaves = 3) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                const offset = i * 31.7;
                value += noise3D(x * frequency + offset, y * frequency + offset, t * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return value / maxValue;
        }

        function loadMap() {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const offscreen = document.createElement('canvas');
                    offscreen.width = img.width;
                    offscreen.height = img.height;
                    const offCtx = offscreen.getContext('2d');
                    offCtx.drawImage(img, 0, 0);
                    
                    const imageData = offCtx.getImageData(0, 0, img.width, img.height);
                    mapData = imageData.data;
                    mapWidth = img.width;
                    mapHeight = img.height;
                    resolve();
                };
                img.onerror = () => {
                    mapData = null;
                    resolve();
                };
                img.src = 'data:image/png;base64,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';
            });
        }

        function isLand(nx, ny) {
            if (!mapData) return false;
            
            const px = Math.floor(nx * (mapWidth - 1));
            const py = Math.floor(ny * (mapHeight - 1));
            const idx = (py * mapWidth + px) * 4;
            
            return mapData[idx] > 128;
        }

        function getLandIntensity(nx, ny) {
            if (!mapData) return 0;
            
            const px = nx * (mapWidth - 1);
            const py = ny * (mapHeight - 1);
            
            const x0 = Math.floor(px);
            const y0 = Math.floor(py);
            const x1 = Math.min(x0 + 1, mapWidth - 1);
            const y1 = Math.min(y0 + 1, mapHeight - 1);
            const fx = px - x0;
            const fy = py - y0;
            
            const getVal = (x, y) => {
                const idx = (y * mapWidth + x) * 4;
                return mapData[idx] / 255;
            };
            
            const v00 = getVal(x0, y0);
            const v10 = getVal(x1, y0);
            const v01 = getVal(x0, y1);
            const v11 = getVal(x1, y1);
            
            const vx0 = v00 + fx * (v10 - v00);
            const vx1 = v01 + fx * (v11 - v01);
            
            return vx0 + fy * (vx1 - vx0);
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        const GAMMA = 2.2;

        function lerpColor(c1, c2, t) {
            const r = Math.pow(lerp(Math.pow(c1.r / 255, GAMMA), Math.pow(c2.r / 255, GAMMA), t), 1 / GAMMA) * 255;
            const g = Math.pow(lerp(Math.pow(c1.g / 255, GAMMA), Math.pow(c2.g / 255, GAMMA), t), 1 / GAMMA) * 255;
            const b = Math.pow(lerp(Math.pow(c1.b / 255, GAMMA), Math.pow(c2.b / 255, GAMMA), t), 1 / GAMMA) * 255;
            return {
                r: Math.round(r),
                g: Math.round(g),
                b: Math.round(b)
            };
        }

        function resize() {
            const dpr = Math.min(2, window.devicePixelRatio || 1);
            const w = Math.floor(canvas.clientWidth * dpr);
            const h = Math.floor(canvas.clientHeight * dpr);
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
            }
        }

        function draw(timestamp) {
            resize();
            
            const dt = lastTime ? (timestamp - lastTime) / 1000 : 0;
            lastTime = timestamp;
            
            if (isHovering) {
                time += dt;
            }
            
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = `rgb(15, 15, 15)`;
            ctx.fillRect(0, 0, w, h);
            
            const cellW = CELL_SIZE;
            const cellH = CELL_SIZE;
            const cols = Math.ceil(w / (cellW + GAP));
            const rows = Math.ceil(h / (cellH + GAP));
            
            const totalW = cols * (cellW + GAP) - GAP;
            const totalH = rows * (cellH + GAP) - GAP;
            const offsetX = (w - totalW) / 2;
            const offsetY = (h - totalH) / 2;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = offsetX + col * (cellW + GAP);
                    const y = offsetY + row * (cellH + GAP);
                    
                    const nx = col / (cols - 1);
                    const ny = row / (rows - 1);
                    
                    const landVal = getLandIntensity(nx, ny);
                    const baseColor = lerpColor(OCEAN_BASE, LAND_BASE, landVal);
                    const accentColor = lerpColor(lerpColor(OCEAN_BASE, ACCENT, 0.5), ACCENT, landVal);
                    
                    let finalColor = baseColor;
                    
                    if (isHovering || time > 0) {
                        let val = 0;

                        val += 0.1;
                        val += fractalNoise(col * 2 - time * 1.5, row * 2, time * 3 + col * 0.32, 1) * 0.04;
                        val += Math.pow(fractalNoise(col * 0.5 - time * 3, row * 0.5 + time * 1, time * 1.5 + col * 0.2, 2), 2) * 0.1;
                        val += fractalNoise(col * 0.15 + landVal * 0.5 - time * 0.2, row * 0.15, time * 0.2, 3) * 0.2;
                        val += Math.max(0, fractalNoise(nx * 1 + landVal * 0.15 - time * 0.2, ny * 1, time * 0.1, 2) * 1 - 0.3);


                        val = 1 / (1 + Math.exp(5-14 * val));
                        finalColor = lerpColor(baseColor, accentColor, val);
                    }
                    
                    ctx.fillStyle = `rgb(${finalColor.r}, ${finalColor.g}, ${finalColor.b})`;
                    ctx.fillRect(x, y, cellW, cellH);
                }
            }
            
            requestAnimationFrame(draw);
        }

        window.addEventListener('message', function(e) {
            if (!e.data || e.data.type !== 'hover') return;
            isHovering = e.data.value;
        });

        window.addEventListener('resize', resize);

        loadMap().then(() => {
            resize();
            requestAnimationFrame(draw);
        });
    </script>
</body>
</html>
