---
color: white
width: 4
code: PRJ.078
title: Owl
category: Project
subtitle: Personal programming language
chip: owl
height: 3
---
Owl is my personal programming language that I occasionally mess around with. It is a mashup of my favorite features from a bunch of languages like Python, Haskell, Go, JavaScript, and Java. Owl is designed to have a clean and compact syntax, which is great for rapid prototyping, experimentation, and messing around with programming language design.

> Fun fact, in an earlier iteration of this website, the server was implemented fully in Owl, although the hosting costs were too high so I had to replace it with a static HTML page :( but it was fun to write HTTP parsers and hook the language into networking libraries.

To give you an idea of what the syntax looks like, here is [FizzBuzz](https://www.geeksforgeeks.org/fizz-buzz-implementation/):

```
FizzBuzz = (end) => {
    i = 0
    while i < end {
	    i++
	    s = []
    	if i % 3 == 0 {
	    	s.Add("Fizz")
	    }
    	if i % 5 == 0 {
		    s.Add("Buzz")
	    }
	    print(s.Join("") or i)
	}
}
```

# Highlights

## Pattern Matching Arguments

Pattern matching is something that I really like about Haskell. It removes the need for most if statements in an elegant way. Haskell has this as a result of its typing system and functional design, but I've always felt it would be a nice feature in other languages. So, Owl has a similar implementation of it. Here's an example of factorial that takes advantage of it.

```
factorial = 0 => 1
          | n => n * factorial(n - 1)

print(factorial(4))
// Prints 24
```

This is accomplished by a combination of function conditionals, and overloading. Function conditionals are expressions that decide whether a function is valid for a given set of inputs, and are generated by the parser. So, if a function contains an expression in the arguments, like the zero in `0 => 1`, the function is parsed as `$0 => 1` with a conditional `$0 == 0`. The `$0` is a dummy variable created by the parser to hold the value. Prefixing with a dollar sign is useful, because it’s illegal for the user to declare variables starting with it, guaranteeing uniqueness. Also because it looks a bit like how bash handles arguments which I find satisfying.

Function conditionals can be combined with overloading to get the desired pattern matching behavior. Unlike most languages, overloading a function is done explicitly with the overload operator `|`. It combines two functions, executing the first if its conditional is met, or the second if it isn't. Multiple overloads can be chained to make more complex branching behaviors.

## Flexible Assignment

Flexible assignment is a single system that handles a bunch of features. To understand it, I should first mention something unusual about Owl, which is that functions can only have one argument. `add(a, b)` looks like it's passing two arguments, but in fact, the comma there isn't a separator, it's an operator.  In Owl, the comma in `a, b` is an operator that returns the list `[a, b]`. This means the function call `add(a, b)` is identical to `add([a, b])`.

Why do it this way? At first it seems restrictive and strange, but it came from realizing that destructuring syntax like `x, y = y, x` or `[a, ...b] = list` looked similar to argument passing, so I decided to unify them.

```
// Assignment is the same as passing args.
x, y = a, b

f = (x, y) => ...
f(a, b)
```

After merging the argument parsing code with the assignment code, everything became much simpler. It also meant that any improvement to arguments also applies to assignments, and the whole thing is incredibly simple, about 60 lines of code. Here are some examples of what Owl can do:

```
// Multiple assignment
x, y = y, x
// Multiple return values
f = (a) => (a, a)
x, y = f(b)
// Spread in assignments
x, ...xs = [1, 2, 3]
// Spread in functions
f = (...b) => b.Sum()
// Nested destructuring in assignments
[a[0], [b, ...c, d]], e.v = [1, [2, 3, 4, 5]], 6
// Nested destructuring in functions
f = (a, ...b, [[c], ...d]) => ...
```

# Design

The language is interpreted, and the interpreter is written in Go. Code is first processed by the lexer, which is implemented mostly with regular expressions to match tokens. The parser then converts the tokens to an abstract syntax tree, which can be used by the executor to run it.

I avoided tools and frameworks meant for building languages like [ANTLR](https://www.antlr.org/) since I wanted this language to be truly my own, and I wanted to understand the underlying mechanics. So, I made them entirely from scratch in Go. The only code that I didn't write myself was the regex engine, since that seemed unnecessarily tedious.

# Types

There are none. Everything in Owl is an `OwlObj`, even the primitive types like bools, strings, lists, and even functions are not distinguishable from any other objects. Owl is a duck typing language, meaning that things are distinguished by capabilities, not types. Because everything is a modifiable object, you can do all sorts of things that other languages can't. Here's an example of changing the meaning of addition for an int:

```
x = 10
// replace x's addition with subtraction
x::add = (a, b) => a - b

print(x + 1)
// This prints 9
```

All objects can be modified using a simple attribute system that is implemented with two dictionaries. The first is the attributes dictionary. It can store arbitrary data and is accessed with `.` much like other languages. So you can do things like `x.value = 3` and then access it later with `x.value`. This allows all objects to act as dictionaries if needed.

The other dictionary that all objects have is the "deep attributes". It stores the functionality that Owl will interact with, and is accessed by `::`. When there's a built-in operator being used like in `a + b`, Owl will resolve it by calling `a::add(b)`. This idea is similar to Python's [dunder methods](https://mathspp.com/blog/pydonts/dunder-methods#what-are-dunder-methods) but doesn't require the weird underscores since the data and functionality of objects are cleanly separated into two dictionaries.

This allows for creating new types that can integrate seamlessly into the language. Here's an example of a basic complex number implementation:

```
complex = (real, imag) => {
    c = {real: real, imag: imag}
    c::mul = (a, b) => {
        r = a.real * b.real - a.imag * b.imag
        i = a.real * b.imag + a.imag * b.real
        return complex(r, i)
    }
    c::str = () => {
        if this.imag == 0 {
            return this.real::str()
        } else if this.real == 0 {
            return this.imag + "i"
        } else if this.imag < 0 {
            return this.real + " - " + -this.imag + "i"
        } else {
            return this.real + " + " + this.imag + "i"
        }
    }
    return c
}
```

After adding that, it's possible to use complex numbers with the built in operators as if they were any other type:

```
i = complex(0, 1)
print(i * i)
// Prints -1
```

# Syntax Highlighting

After using the language for a while, I got tired of looking at code without any colors, so I made a custom VS Code extension to add support for the language. And now the code looks ✨fabulous✨

Here's part of the JSON parser for this site before and after adding the highlighter.

![](assets/owl-highlight.png)

To make this work, I had to make a second implementation of my lexer in [TextMate](https://macromates.com/manual/en/language_grammars), since that's the format that VS Code uses for syntax highlighting. It was a bit of work to implement, but the quality of life improvement was huge. The colors make syntax errors easier to spot, and also make it feel like a real language.

# Optimization

The language is highly optimized — for a very specific definition of optimized. It’s optimized for the way I think about programming. I’m not trying to make the next C++, or explore category theory with an axiomatic type system. I want to mess around and have a language that works in the ways I want it to, and that’s what the language is most optimized for.

All that is to say that, in a performance sense, it’s not at all optimized. I have never run into a case where performance has been an issue, and I don’t intend to optimize it until it becomes a problem. My goal at the moment is to keep the interpreter flexible and readable so I can try new things easily. Optimization is inherently about making assumptions about a problem to solve it more efficiently, but I don’t want to be making assumptions, since they might be broken by the next feature I want to add.

This has resulted in most features of the language being represented by operators, since they’re easy to add, easy to remove, and have a generic syntax that is already well supported by the parser. This might have been obvious when I mentioned earlier that commas are operators, and so are overloaded functions. It’s a great way to keep things simple, and not get too focused on fancy syntax or ad hoc solutions to each problem.

# Conclusion

Owl is fun! It turned out better than I had expected, and has been a lot of fun to work on. I’m still occasionally adding new features to it as I come up with ideas. Check out the [GitHub](https://github.com/AnthonyEdvalson/owl) if you want to see more details, or want to try it out for yourself!